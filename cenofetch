#!/usr/bin/env node
const { match } = require('assert');
const fs = require('fs');
const os = require('os');
const spawn = require('child_process').spawn;
const clean_reg = /\n.*/;
const reset_color = "\u001b[0m";
const black_color = "\033[30;40m";
const white_color = "\033[37;47m";
const red_color = "\033[31;41m";
const bold_colored = "\u001b[36m\u001b[1m"
const set_cursor = (amount, direction) => "\033[" + amount + direction;

const logo = [
    "                    " + black_color + "./osssso+:." + reset_color,
    "                " + black_color + "`+ydm" + red_color + "dddddhhhh" + black_color + "dds/`" + reset_color,
    "               " + black_color + ":m" + red_color + "dddddddmddddddhhh" + black_color + "hs:`" + reset_color,
    "              " + black_color + ".m" + red_color + "mmdmmmmmddddddddddhhh" + black_color + "ho-" + reset_color,
    "             " + black_color + "`m" + red_color + "mNmmmmmmdddddddddd" + black_color + "dhs++sdh/:" + reset_color,
    "            " + black_color + ".d" + red_color + "mNmNNNmmmmmdd" + black_color + "dossso`" + white_color + "         " + black_color + ".y" + reset_color,
    "           " + black_color + "+d" + red_color + "mmmmMNmmmmm" + black_color + "mmh+" + white_color + "          ``  ```" + black_color + ":/`" + reset_color,
    "    " + black_color + "`///oohm" + red_color + "mmmmmNmm" + black_color + "mmNo/." + white_color + "     ```....---:-.``" + black_color + "/o" + reset_color,
    "  " + black_color + ".s+" + white_color + "-    " + black_color + "`-+m" + red_color + "ssNNm" + black_color + "Ns." + white_color + "     ```.:+" + black_color + "h:----..+y:.`//" + reset_color,
    black_color + "`oh" + white_color + "-`        " + black_color + ".h" + red_color + "m" + black_color + "hNm" + black_color + "y." + white_color + "    ```" + black_color + "./o//:" + reset_color,
    black_color + "`o" + white_color + "/.```     `" + black_color + "s+-." + white_color + "     ``.-o" + black_color + "o:" + reset_color,
    " " + black_color + "sy" + white_color + "/..`.` ``-" + black_color + "h.`" + white_color + "      `.-:" + black_color + "+`" + reset_color,
    "  " + black_color + "/h+" + white_color + "-:--../" + black_color + "ym:." + white_color + "``..." + black_color + "-+o+:`" + reset_color,
    "    " + black_color + ":hosh/:`o/" + white_color + "---:" + black_color + "oo-." + reset_color,
    "            " + black_color + "-++s/:`" + reset_color
];

const logo_size = Math.max(...logo.map(line => {
    const logo_clean_regex = /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g
    const cleaned_line = line.replace(logo_clean_regex, "");
    return cleaned_line.length;
}));

const reduce_to_string = (prev_match, curr_match) => {
    if (typeof prev_match === "string") {
        return prev_match += ' ' + curr_match[1];
    } else {
        return prev_match[1] += ' ' + curr_match[1];
    }
};

const get_term = () => {
    return {
        title: bold_colored + "Terminal: " + reset_color,
        info: process.env.TERM_PROGRAM
    }
};

const get_title = () => {
    return {
        title: "",
        info: bold_colored + os.userInfo().username + reset_color + "@" + bold_colored + os.hostname() + reset_color
    }
};

const get_divider = () => {
    return {
        title: "",
        info: new Array(os.userInfo().username.length + os.hostname().length + 1).fill('-').reduce((p, c) => p + c)
    }
};

const get_kernel = () => {
    return {
        title: bold_colored + "Kernel: " + reset_color,
        info: os.type()
    };
};

const get_os = () => {
    return {
        title: bold_colored + "OS: " + reset_color,
        info: "Windows " + require('os').release().split('.')[0]
    }
};

const get_memory = () => {
    const total_memory = os.totalmem();
    return {
        title: bold_colored + "Memory: " + reset_color,
        info: Math.round(total_memory / (1024 * 1024)) + "MB"
    };
};

const get_cpu = () => {
    const cpus = os.cpus();
    const cleanup_match = /(^model name\s*:\s*|\s@.*$|\(TM\)|\(R\))/g
    const cleaned_model = cpus[0]?.model.replace(cleanup_match, "");
    const cpu_info = {
        model: cleaned_model,
        cores: cpus.length
    }
    const cpu_max_freq = os.cpus()[0].speed / 1000
    return {
        title: bold_colored + "CPU: " + reset_color,
        info: cpu_info.model + "(" + cpu_info.cores + ")" + " @ " + cpu_max_freq + "GHz"
    }
}

const get_model = () => {
    return {
        title: bold_colored + "Host: " + reset_color,
        info: require('os').hostname()
    }
};

const get_gpu = () => new Promise((resolve, reject) => {
    const find_windows_gpu = spawn('wmic', ['path', 'win32_VideoController', 'get', 'name']);
    find_windows_gpu.stdout.on('data', data => {
        const gpu_windows_regex = /Name\s*(.*)\s*/gm
        const matches = [...data?.toString().matchAll(gpu_windows_regex)];
        const reduced = matches[0][1];
        resolve({
            title: bold_colored + "GPU: " + reset_color,
            info: reduced
        });
    });
});

const get_wm = () => {
    return {
        title: bold_colored + "WM: " + reset_color,
        info: "Explorer"
    }
};

const get_resolution = () => new Promise((resolve, reject) => {
    const find_resolution = spawn('wmic', ['path', 'Win32_VideoController','get','VideoModeDescription','\/value']);
    find_resolution.stdout.on('data', data => {
        const find_resolution_regex = /VideoModeDescription=\d* x \d*/gm;
        const match = data?.toString().match(find_resolution_regex);
        const format_matches = match[0]?.substring(21);
        resolve({
            title: bold_colored + "Resolution: " + reset_color,
            info: format_matches
        });
    });
});

const get_uptime = () => {
    return {
        title: bold_colored + "Uptime: " + reset_color,
        info: Math.round(os.uptime() / 60 / 60) + 'h'
    }
};

const get_colors1 = () => {
    return {
        title: "",
        info: new Array(8).fill().map((x, i) => "\u001b[48;5;" + i + "m").reduce((p, c) => p + '   ' + c) + reset_color
    }
}

const get_colors2 = () => {
    return {
        title: "",
        info: new Array(8).fill().map((x, i) => "\u001b[48;5;" + (i + 8) + "m").reduce((p, c) => p + '   ' + c) + reset_color
    }
}

const main = () => {
    Promise.all([
        get_title(),
        get_divider(),
        get_os(),
        get_model(),
        get_kernel(),
        get_uptime(),
        get_cpu(),
        get_gpu(),
        get_memory(),
        get_term(),
        get_wm(),
        get_resolution(),
        get_colors1(),
        get_colors2()])
        .then(result => {
            result.forEach((info, i, array) => {
                if (array.length - 1 === i) {
                    process.stdout.write(set_cursor(logo_size + 1, "C") + info.title + info.info);
                } else {
                    process.stdout.write(set_cursor(logo_size + 1, "C") + info.title + info.info + "\n");
                }
            });
            process.stdout.write(set_cursor(result.length - 1, "A") + "\r");
            logo.forEach(line => {
                process.stdout.write(line + "\n");
            });
        });
};
main();